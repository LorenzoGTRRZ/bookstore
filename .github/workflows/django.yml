name: Django CI # Nome do seu workflow

on:
  push:
    branches: [ main ] # Dispara o workflow em push para a branch main
  pull_request:
    branches: [ main ] # Dispara o workflow em pull request para a branch main

jobs:
  test: # Define um job chamado 'test'
    runs-on: ubuntu-latest # O job será executado em uma máquina virtual Ubuntu

    services:
      postgres: # Define um serviço de banco de dados PostgreSQL
        image: postgres:12 # Imagem Docker do PostgreSQL versão 12
        env:
          POSTGRES_DB: bookstore # Nome do banco de dados para o CI/CD
          POSTGRES_USER: postgres # Usuário do banco de dados para o CI/CD
          POSTGRES_PASSWORD: postgres # Senha do banco de dados para o CI/CD
        ports:
          - 5432:5432 # Mapeia a porta do PostgreSQL
        options: >- # Opções de saúde para garantir que o DB esteja pronto
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env: # Variáveis de ambiente globais para os passos do job
      # CORREÇÃO CRÍTICA: Use 'postgres' como host, não 'localhost'.
      # Dentro do ambiente do CI/CD, 'postgres' é o nome do serviço do banco de dados,
      # que o Docker Compose (e o runner do GitHub Actions) irá resolver para o IP correto.
      DATABASE_URL: postgres://postgres:postgres@postgres:5432/bookstore

    steps: # Passos a serem executados no job
    - name: Checkout code # Passo para clonar o seu repositório
      uses: actions/checkout@v3

    - name: Set up Python # Passo para configurar o ambiente Python
      uses: actions/setup-python@v4
      with:
        # Recomendação: Alinhe esta versão com a versão Python que você usa no seu Dockerfile (3.12.1-slim)
        python-version: '3.12' # Alterado de '3.10' para '3.12'

    - name: Install dependencies # Passo de instalação de dependências aprimorado
      run: |
        echo "Verificando diretório de trabalho:"
        pwd # Mostra o diretório atual
        echo "Listando arquivos no diretório de trabalho:"
        ls -l # Lista os arquivos no diretório atual para depuração

        # 1. Instale o Poetry no ambiente do CI/CD
        python -m pip install poetry

        # 2. Configure o Poetry para criar o ambiente virtual dentro do diretório do projeto
        poetry config virtualenvs.in-project true

        # 3. Instale as dependências usando Poetry.
        #    -vvv: Adiciona muita verbosidade para ajudar a depurar se houver problemas na instalação.
        poetry install --no-root --only main -vvv

        echo "Verificando se o Django e outras libs foram instaladas no venv:"
        # Tenta executar um comando Python usando o intérprete do ambiente virtual
        # e verifica se as libs essenciais estão lá.
        .venv/bin/python -c "import django; print('Django version:', django.VERSION)" || true
        .venv/bin/python -c "import dj_database_url; print('dj_database_url found')" || true
        .venv/bin/python -c "import drf_spectacular; print('drf_spectacular found')" || true


    - name: Run migrations # Passo para rodar as migrações do Django
      # CORREÇÃO: Use explicitamente o python do ambiente virtual criado pelo Poetry.
      # Isso garante que você está usando as dependências instaladas pelo Poetry, e não o python global.
      run: |
        .venv/bin/python manage.py migrate

    - name: Run tests # Passo para rodar os testes do Django
      # CORREÇÃO: Use explicitamente o python do ambiente virtual criado pelo Poetry.
      run: |
        .venv/bin/python manage.py tests